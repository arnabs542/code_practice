package mj_fb;

import ds.Interval;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;

public class FB_Coding4 {
    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }

    /*
     * http://www.1point3acres.com/bbs/forum.php?mod=collection&action=view&ctid=275
     *
     */

    /*
     * 1
     * Integer to Roman && Roman to Integer
     */
    public static int romanToInt(String s) {
        return -1;
    }

    public static String IntToRoman(int n) {
        return null;
    }

    /*
     * 给一个一堆单词的字典，判断单词是否在字典中，“.”可以匹配任意字符
     * Trie
     */

    /*
     * LC297， 树的各种traversal，总之followup 会让你各种遍历方式都试一试的。然后分析时间空间复杂度，如何证明复杂度bounded by 什么什么的.
     * https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
     *
     *
     * LC157/158， 经典的稀疏vector乘积，图的traversal，证明复杂度
     * 157. Read N Characters Given Read4
     *
     * 158. Read N Characters Given Read4 II - Call multiple times   Add to List QuestionEditorial Solution
     * https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/
     */

    /*
     * behavioral questions + Strstr
     *
     * add binary + Valid Palindrom
     *
     * Construct Binary Tree from Inorder and Postorder Traversal + Set Matrix Zeroes
     */

    /*
     * http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=193545&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3088%5D%5Bvalue%5D%3D1%26searchoption%5B3088%5D%5Btype%5D%3Dradio%26searchoption%5B3089%5D%5Bvalue%5D%5B3%5D%3D3%26searchoption%5B3089%5D%5Btype%5D%3Dcheckbox%26searchoption%5B3090%5D%5Bvalue%5D%3D1%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311
     *
     * Tri-node的题
     *
     *
     * 求String B是不是String A的substring
     * strStr()
     *
     * 找sorted array中的某个数，用divide & conquer做
     *
     *
     */

    /*
     *  convert string to double   -12.35e2 -> double。。这题可以assume给的string都是valid的
     *
     */


    /*
     * 3.1 subset product, follow up if duplicate exists. From 1point 3acres bbs
     * 3.2 find root to leaf path sum to target, follow up, what if all node's value are positive-google 1point3acres
     * 4.1 divide two Integers. From 1point 3acres bbs
     * 4.2 merge K arrays.
     */

    /*
     * binary tree to DLL and DLL to binary tree
     * find minimum in a rotated array.
     * pain houses using k colors
     *
     * make parenthesis valid
     *
     * num of islands
     *
     * 3 color sorting
     */

    /*
     * 1) 检查palindrome, 需要过滤数字，不区分大小写； 2）serialize, deserialize 二叉树<->linkedlist
     * 2) behavior + merge 两个array
     * 3) regular expression
     * 4)
     */

    /*
     * http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=206360&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3088%5D%5Bvalue%5D%3D1%26searchoption%5B3088%5D%5Btype%5D%3Dradio%26searchoption%5B3089%5D%5Bvalue%5D%5B3%5D%3D3%26searchoption%5B3089%5D%5Btype%5D%3Dcheckbox%26searchoption%5B3090%5D%5Bvalue%5D%3D1%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311
     *
     * 重点关注一下
     */

    /*
     * http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=146863&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3088%5D%5Bvalue%5D%3D1%26searchoption%5B3088%5D%5Btype%5D%3Dradio%26searchoption%5B3089%5D%5Bvalue%5D%5B3%5D%3D3%26searchoption%5B3089%5D%5Btype%5D%3Dcheckbox%26searchoption%5B3090%5D%5Bvalue%5D%3D1%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311
     * sort colors但是扩展到k个color 写一点代码
     *
     * minimum window containsing a string (LC 原题) + n th Fibonacci number mod 10
     *
     * 1~60
     * 61~120
     * 121~180
     *
     * 平面上离原点最近的k nearest points
     * 楼主说可以priorityqueue。大哥说不错，挺满意。结果楼主一紧张说也可以select k
     *
     * 打印树的所有根到叶子的所有路径
     * count islands (DFS BFS disjoint set)
     *
     */

    /*
     * one edit distance
     *  sparse vector
     *  subsets I and II
     *
     */

    /*
     * Group Anagrams,
     * Inorder Successor in BST  follow up O(log n)
     * 29 divide two numbers (出了个小bug, 而且现场写了一个(lgn ^2) 的算法(基于位运算的)).
     * 283 Move Zeroes 不要求保持原来顺序，讨论，秒掉
     *
     *
     */

    /*
     * http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=148865&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3088%5D%5Bvalue%5D%3D1%26searchoption%5B3088%5D%5Btype%5D%3Dradio%26searchoption%5B3089%5D%5Bvalue%5D%5B3%5D%3D3%26searchoption%5B3089%5D%5Btype%5D%3Dcheckbox%26searchoption%5B3090%5D%5Bvalue%5D%3D1%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311
     *
     * paint house大变种. n houses, k colors. neighboring houses cannot be painted with the same color.
     * 求minimum cost的涂法，每个颜色有cost。。。问每个house涂什么颜色 BFS做的。。。不过给了hint
     * 看做一个graph。然后分组。初始所有house都为group 0
     * 用bfs遍历这个图。然后根据相邻house颜色不一样改变组号。。。
     * 最后颜色根据cost排序，然后最大group的house涂cost最小的颜色，以此类推
     *
     * NOTICE: neighboring relationship is given by adjacent list which means a house may have multiple neighbors.
     *
     * reverse Linkedlist (both recursive and iterative). buy and sell stock I, II (output transaction)
     *
     * behavior questions/research. coding: clone graph. give a class Graph, return 一个clone的
     *
     * lc 53， lc 98
     *
     *
     * previous permutation. 1po
     *
     * read4K
     *
     */

    /*
     * reservior sampling，union find，LC 277，34，126，多叉树最深叶节点的LCA
     *
     *
     * coding postorder tree iterative。
     *
     */

    /*
     * 1.input friends relation {{1，2}， {2，3}， {3，4}} 把用户存在两个group里，
     * 每个group里大家都不互相认识。所以exp应该g1{1，3} g2{2，4}。
     * range是1-n， 所以loop从一开始， 放到group1里面，然后他的朋友放group2里面，
     * 用一个flag记录放哪个，比如这轮group1，flag = 1， 下一轮flag = 0， 就放group2. 相当于说这一层的人放1， 那下一层就放0.
     * 一直到结束就可以了。然后每次要看如果如果已经放入1了，但是这次要放入0，就说明invalid。 比如{1，2} {2，3}{1，3}。
     *
     *
     *
     * [面试经验] 地里2016年度所有Facebook面试题总结
     * http://www.1point3acres.com/bbs/thread-203983-1-1.html
     *
     *
     *
     *
     */

    /*
     * 第一题离原点最近k point，说了prirority_queue和partition两种方法，让我写了前者，bug free，
     * 然后问我循环里可不可以优化，因为是logk，我说怎么可能优化，要维持k size，然后他就给我举个例子，
     * 如果push的是最大的，我就立马懂了，不用push进去，加个判断条件。第二题，clone graph，秒，然后解释的时候，
     * 他问如果最后为空，我说对，push的时候要加个判断，刚准备改，我立马意识到不对，就说可以不用加，
     * 因为空的时候最开始就不出现在children数组中，他说对，不过never mind，时间还有6分钟左右，我就问在做一道题吗，他说时间不够，问问题吧。
     *
     * 第一题decode way，从后往前dp，空间优化，bug free
     * 树转成double linked list
     *
     *
     */

    /*
     * convert binary tree to linked list.
     * number of islands
     * check if a binary tree is mirrored
     * leetcode 211 原题， add and search word
     * 最后一轮的follow up是如何利用trie做google 的type ahead feature。
     * 我的做法是每个trie node加一个weight,和维护一个top n words priority queue for his subtree
     *
     * 算法题面试官都会问你空间时间复杂度，worst case, best case, avg case都要知道。
     *
     */

    /*
     * LC211
     * http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=211154&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3088%5D%5Bvalue%5D%3D1%26searchoption%5B3088%5D%5Btype%5D%3Dradio%26searchoption%5B3089%5D%5Bvalue%5D%5B3%5D%3D3%26searchoption%5B3089%5D%5Btype%5D%3Dcheckbox%26searchoption%5B3090%5D%5Bvalue%5D%3D1%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311
     *
     * 欧洲manager，聊天都是要高度概括之前的经历，不需要详细的例子，问的就是比如你觉得做project你最enjoy哪个部分，最tricky的是哪个部分，每个project大概做多久呀之类的。之前准备过亚麻的behavior觉得这些问题都很好答，起码他没有细问。 然后一道light coding，不记得了，很简单的encode
     *
     * subarray=target，返回boolean就行+ k closest points
     *
     * 一个bit map，是immutable的，有很多query要返回某个区域内的sum，其实就是LC range sum 2D immutable的简单版，因为matrix只有0和1.
     *
     */

    /*
     * k个二进制数相加
     *
     * 给一个数组，每个元素有一个概率，写一个函数按照每个元素的概率每次返回一个元素。比如1：0.2，2：0.3，3：0.5    返回1的概率是0.2，返回3的概率是0.5
     *
     * serialize和deserialize二叉树
     *
     * coding：反向打印链表.
     *
     */

    /*
     * climbing stairs， rotate matrix
     * Populating Next Right Pointers in Each Node II,
     * regex matching, decoding ways, two sums
     *
     *
     * read4()
     *
     */

    /*
     * 1. BQ 二叉树某给定深度的节点的平均值
     * 2. 移动零 + 电话号码数字到字母的组合
     * 3. 3SUM + 序列化反序列化二叉树
     *
     */

    /*
     * behavior＋移动零
     *
     * 数组里找最长的连续儿子数组，sum 等于一个 target
     *
     * 二叉树拍扁了再拉起来  Binary Tree to linked list and linked list to binary tree
     *
     * 做除法以字符串形式返回。第一问是给定精确到小数点后几位，第二问是识别无限循环把循环的部分框起来
     *
     */

    /*
     * find pair for domino，题的意思是有一袋子的多米诺骨牌，每个牌上有两个数字，上下各一个，都在1-6之间，
     * 要找出有没有两个match的骨牌，match的定义是两组数加起来都是6，比如一个骨牌是（1,5），
     * 那么match的骨牌是（1,5）或者（5,1），总之相当弱智的一题，用哈希表解决，存的时候存个pair，找的时候找两下就行了
     *
     *
     * most frequent char in string，一个谷歌跳过来的美国人，感觉很有经验也很厉害，全程调戏我，这题就是给个string，
     * 找出最常出现的char，我就说建个vector<int>数组统计一下ASCII的字符，再扫一遍找最大，写完了他质疑我的代码有问题，我没看出来，
     * 他说char有可能是signed，我还真第一知道还有signed/unsigned char，表示服气，后来就问复杂度，
     * 说完之后让改进，我就懵逼了，这还能怎么改进，都O（N）时间+constant space了，绞尽脑汁也不会。
     * 他说万一我的string很长，几百万个char怎么办，还问我要执行多久，我说这得看你什么处理器了，
     * 他说大概呢，我说大概几秒到几十秒吧，他又细问你有多大的置信区间在这个时间段，楼主无语了，当时就想说我能拿个电脑跑一下么。
     * 后来他又提示说给你一本书你怎么找最常出现的字母，而且给你5分钟，我说那就随机挑几页，他终于有点满意了，说怎么随机挑呢，我说找字多的页，
     * 但是随机统计出来的结果不一定正确，他又问我你有多大的percentage能确定，我说这根据你读了多少页，这书有多少页，
     * 然后他又问我具体数字，再次无语。最后问我多机怎么处理，我说每个机器统计一遍，再把结果汇总。废话有点多，总之这轮很无语，
     * 一直被调戏，感觉就是考思维吧。 sampling
     *
     * N-dimension array sum + clone graph，第一个题给个class是N维数组，可以access每个数，
     * 求和，比如2x2的矩阵有四个数，3x3x3的矩阵有27个数，都加起来就行。
     * 递归backtrack解的，有点像subset的感觉。具体大概是这样的
     *
     * class Narray {
     * . from: 1point3acres.com/bbs
     * vector<int> dimensions;
     *     int getNum(vector<int> index);
     *     }
     *     让写的是
     *     int getSum(Narray narray) {
     *     }
     *     clone graph就是lc原题了
     *
     *
     * http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=216560&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3088%5D%5Bvalue%5D%3D1%26searchoption%5B3088%5D%5Btype%5D%3Dradio%26searchoption%5B3089%5D%5Bvalue%5D%5B3%5D%3D3%26searchoption%5B3089%5D%5Btype%5D%3Dcheckbox%26searchoption%5B3090%5D%5Bvalue%5D%3D1%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311
     *
     */

    /*
     * task31
     * Merge K Sorted List of Intervals
     */
    public static void test31() {
        List<Interval> list1 = new ArrayList<Interval>();
        list1.add(new Interval(1,3));
        list1.add(new Interval(5, 9));
        list1.add(new Interval(11, 15));

        System.out.println("------------------");
        for(Interval i : list1) {
            System.out.println("[ " + i.start + "  " + i.end + "  ]");
        }
        System.out.println("-------------------");

        List<Interval> list2 = new ArrayList<Interval>();
        list2.add(new Interval(2,4));
        list2.add(new Interval(15, 17));
        List<Interval> list3 = new ArrayList<Interval>();
        list3.add(new Interval(5, 10));
        list3.add(new Interval(12, 17));
        list3.add(new Interval(19,21));

        System.out.println("------------------");
        for(Interval i : list2) {
            System.out.println("[ " + i.start + "  " + i.end + "  ]");
        }
        System.out.println("-------------------");

        System.out.println("------------------");
        for(Interval i : list3) {
            System.out.println("[ " + i.start + "  " + i.end + "  ]");
        }
        System.out.println("-------------------");

        List<List<Interval>> input = new ArrayList<List<Interval>>();
        input.add(list1);
        input.add(list2);
        input.add(list3);

        System.out.println("====================");

        List<Interval> result = task31_mergeKSortedListOfInterval(input);
        for(Interval i : result) {
            System.out.println("[ " + i.start + "  " + i.end + "  ]");
        }
    }


    public static List<Interval> task31_mergeKSortedListOfInterval(List<List<Interval>> input) {
        int k = input.size();
        List<Interval> result = new ArrayList<Interval>();

        PriorityQueue<Element> minHeap = new PriorityQueue<Element>(k, myComp2);
        for(int i = 0; i < input.size(); i++) {
            if (input.get(i) == null || input.get(i).size() == 0) {
                continue;
            }
            minHeap.add(new Element(input.get(i).get(0), i, 0));
        }

        Interval candidate = null;
        while(!minHeap.isEmpty()) {
            Element curElem = minHeap.poll();
            int rowIdx = curElem.rowIdx;
            int colIdx = curElem.colIdx;
            Interval cur = curElem.interval;
            if (candidate == null) {
                candidate = cur;
            } else {
                // there is overlap
                if (candidate.end >= cur.start) {
                    candidate.start = Math.min(candidate.start, cur.start);
                    candidate.end = Math.max(candidate.end, cur.end);
                } else {
                    // there is no overlap
                    result.add(candidate);
                    // update candidate
                    candidate = cur;
                }
            }
            if (colIdx + 1 < input.get(rowIdx).size()) {
                minHeap.add(new Element(input.get(rowIdx).get(colIdx + 1), rowIdx, colIdx + 1));
            }
        }
        if (candidate != null) {
            result.add(candidate);
        }
        return result;
    }

    public static Comparator<Element> myComp2 = new Comparator<Element>() {

        @Override
        public int compare(Element o1, Element o2) {
            // TODO Auto-generated method stub
            if (o1.interval.start == o2.interval.start) {
                if (o1.interval.end == o2.interval.end) {
                    return 0;
                }
                return o1.interval.end < o2.interval.end ? -1 : 1;
            }
            return o1.interval.start < o2.interval.start ? -1 : 1;
        }

    };

    public static class Element{
        Interval interval;
        int rowIdx;
        int colIdx;
        public Element(Interval i, int r, int c) {
            this.interval = i;
            this.rowIdx = r;
            this.colIdx = c;
        }
    }
}
